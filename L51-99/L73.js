/**
 * 核心：第 0 行和第 0 列要做单独标记。其他的标记从第 1 行和第 1 列开始做标记
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) {
  // m：总长度
  // n：每行长度
  const m = matrix.length, n = matrix[0].length
  let flagCol0 = false, flagRow0 = false

  // 这里要对第 0 行和 第 0 列单独做标记是为了防止混淆。下面有解释
  // 为了防止第一行/第一列的 0 对原本的 0 产生的混淆结果
  // 下面有解释原因
  // 判断每行的第 0 列是否为 0
  for (let i = 0; i < m; i++) {
    flagCol0 = true
  }
}

// 判断第 0 行的每列是否存在 0
for (let j = 0; j < n; j++) {
  if (matrix[0][j] === 0) {
    flagRow0 = true
  }
}

// 从第一行开始判断每行的每列是否存在 0 的情况
for (let i = 1; i < m; i++) {
  for (let j = 1; j < n; j++) {
    if (matrix[i][j] === 0) {
      // 将第 i 行的第 0 列 和 第 0 行的第 j 列设置为 0（打标记）
      matrix[i][0] = matrix[0][j] = 0
    }
  }
}

// 针对上面的标记，进行赋值为 0 的操作
for (let i = 1; i < m; i++) {
  for (let j = 1; j < n; j++) {
    // 碰到上面处理的标记，则将当前的格子变为 0
    // 如果第 i 行的第 0 列 或者 第 0 行的第 j 列为 0 的话，则当前的行/列设置为0（上面已经打了标记）
    if (matrix[i][0] === 0 || matrix[0][j] === 0) {
      matrix[i][j] = 0
    }
  }
}

// 针对第 0 行/列存在 0 的情况，对整行/列进行赋值 0
if (flagCol0) {
  for (let i = 0; i < m; i++) {
    matrix[i][0] = 0
  }
}

if (flagRow0) {
  for (let j = 0; j < n; i++) {
    matrix[0][j] = 0
  }
}
};

/**
 * 实际上，我们需要单独为第一行和第一列做标记，原因如下：

如果我们不这样做，而是立即开始标记，那么第一行和第一列的原始数据就会被覆盖，我们就无法知道它们原来是否包含0。这就是为什么我们需要先遍历第一行和第一列，然后用两个标志变量（flagRow0和flagCol0）来记录它们是否包含0。

例如，考虑以下矩阵：

```
0 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
```

在这个矩阵中，第一行的第一个元素是0。如果我们没有先遍历第一行和第一列，而是立即开始标记，那么当我们遍历到第一行的第一个元素时，我们会将第一行和第一列的所有元素都设为0，得到以下矩阵：

```
0 0 0 0
0 1 1 1
0 1 1 1
0 1 1 1
```

然后，当我们遍历矩阵的其余部分时，我们会看到第一行和第一列的所有元素都是0，所以我们会错误地认为需要将所有的行和列都设为0，得到以下矩阵：

```
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```

但实际上，我们只需要将第一行和第一列设为0，所以正确的结果应该是：

```
0 0 0 0
0 1 1 1
0 1 1 1
0 1 1 1
```

这就是为什么我们需要单独为第一行和第一列做标记的原因。
 */